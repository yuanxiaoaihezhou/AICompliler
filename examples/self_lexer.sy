// Complete lexer implementation for self-hosting compiler
// Demonstrates that current language features are sufficient for lexical analysis

// Token type constants
const int TOKEN_EOF = 0;
const int TOKEN_INT = 1;
const int TOKEN_CHAR = 2;
const int TOKEN_VOID = 3;
const int TOKEN_IF = 4;
const int TOKEN_ELSE = 5;
const int TOKEN_WHILE = 6;
const int TOKEN_RETURN = 7;
const int TOKEN_IDENT = 10;
const int TOKEN_NUMBER = 11;
const int TOKEN_PLUS = 20;
const int TOKEN_MINUS = 21;
const int TOKEN_MULT = 22;
const int TOKEN_DIV = 23;
const int TOKEN_LPAREN = 30;
const int TOKEN_RPAREN = 31;
const int TOKEN_LBRACE = 32;
const int TOKEN_RBRACE = 33;
const int TOKEN_SEMICOLON = 34;
const int TOKEN_ASSIGN = 35;

// Lexer state
int current_pos;
int current_line;
int current_col;

// Character classification functions
int is_whitespace(char c) {
    if (c == ' ') return 1;
    if (c == '\t') return 1;
    if (c == '\n') return 1;
    if (c == '\r') return 1;
    return 0;
}

int is_alpha(char c) {
    if (c >= 'a') {
        if (c <= 'z') return 1;
    }
    if (c >= 'A') {
        if (c <= 'Z') return 1;
    }
    if (c == '_') return 1;
    return 0;
}

int is_digit(char c) {
    if (c >= '0') {
        if (c <= '9') return 1;
    }
    return 0;
}

int is_alnum(char c) {
    if (is_alpha(c)) return 1;
    if (is_digit(c)) return 1;
    return 0;
}

// Keyword checking
int is_keyword_int(char c1, char c2, char c3) {
    if (c1 == 'i') {
        if (c2 == 'n') {
            if (c3 == 't') {
                return 1;
            }
        }
    }
    return 0;
}

int is_keyword_if(char c1, char c2) {
    if (c1 == 'i') {
        if (c2 == 'f') {
            return 1;
        }
    }
    return 0;
}

int is_keyword_char(char c1, char c2, char c3, char c4) {
    if (c1 == 'c') {
        if (c2 == 'h') {
            if (c3 == 'a') {
                if (c4 == 'r') {
                    return 1;
                }
            }
        }
    }
    return 0;
}

// Character to int conversion
int char_to_int(char c) {
    return c - '0';
}

// Simple number parser
int parse_number(char c) {
    int value;
    value = char_to_int(c);
    return value;
}

// Tokenize a single character operator
int tokenize_operator(char c) {
    if (c == '+') return TOKEN_PLUS;
    if (c == '-') return TOKEN_MINUS;
    if (c == '*') return TOKEN_MULT;
    if (c == '/') return TOKEN_DIV;
    if (c == '(') return TOKEN_LPAREN;
    if (c == ')') return TOKEN_RPAREN;
    if (c == '{') return TOKEN_LBRACE;
    if (c == '}') return TOKEN_RBRACE;
    if (c == ';') return TOKEN_SEMICOLON;
    if (c == '=') return TOKEN_ASSIGN;
    return TOKEN_EOF;
}

// Main lexer demonstration
int lex_demo() {
    char test_char;
    int token;
    int num_value;
    
    // Test character classification
    test_char = 'a';
    if (is_alpha(test_char)) {
        token = TOKEN_IDENT;
    }
    
    test_char = '5';
    if (is_digit(test_char)) {
        num_value = char_to_int(test_char);
        token = TOKEN_NUMBER;
    }
    
    // Test operator recognition
    test_char = '+';
    token = tokenize_operator(test_char);
    
    return token;
}

// Main function
int main() {
    int result;
    
    // Initialize lexer state
    current_pos = 0;
    current_line = 1;
    current_col = 1;
    
    // Run lexer demonstration
    result = lex_demo();
    
    return result;
}
